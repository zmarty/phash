<#@ template language="C#" debug="True" #>
<#@ output extension="cs" #>
using System;
namespace Shipwreck.Phash.Imaging
{
	using EX = ImageExtensions;
<#
var types = new []
{
	new ImageType()
	{
		TypeName = "FloatImage",
		ElementType = typeof(float)
	},
	new ImageType()
	{
		TypeName = "ByteImage",
		ElementType = typeof(byte),
		AdditiveType = typeof(int)
	}
};

foreach(var t in types)
{
	var T = t.TypeName;
	var ET = t.ElementType.FullName;
	var AET = (t.AdditiveType ?? t.ElementType).FullName;
#>
	partial class <#= T #> : IArrayImage<<#= ET #>>, IImageOperatorProvider<<#= ET #>>
	{
        private readonly int _Width;
        private readonly int _Height;
        private readonly <#= ET #>[] _Data;
		
        public <#= T #>(int width, int height)
        {
            _Width = width;
            _Height = height;
            _Data = new <#= ET #>[width * height];
        }

        public <#= T #>(int width, int height, <#= ET #> value)
        {
            _Width = width;
            _Height = height;
            _Data = new <#= ET #>[width * height];
            for (var i = 0; i < _Data.Length; i++)
            {
                _Data[i] = value;
            }
        }

        public <#= T #>(int width, int height, <#= ET #>[] data)
        {
            _Width = width;
            _Height = height;
            _Data = data;
        }
		
        public int Width => _Width;
        public int Height => _Height;
		public <#= ET #>[] Array => _Data;

        public <#= ET #> this[int x, int y]
        {
            get
            {
                var i = x + y * _Width;
                return _Data[i];
            }
            set
            {
                var i = x + y * _Width;
                _Data[i] = value;
            }
        }
		
		public <#= AET #> Max()
		{
			<#= AET #> r = 0;
			for (var i = 0; i < _Data.Length; i++)
			{
				r = Math.Max(_Data[i], r);
			}
			return r;
		}
		public <#= AET #> Min()
		{
			<#= AET #> r = 0;
			for (var i = 0; i < _Data.Length; i++)
			{
				r = Math.Min(_Data[i], r);
			}
			return r;
		}
		public <#= AET #> Sum()
		{
			<#= AET #> r = 0;
			for (var i = 0; i < _Data.Length; i++)
			{
				r += _Data[i];
			}
			return r;
		}

		IImageOperator<<#= ET #>> IImageOperatorProvider<<#= ET #>>.GetOperator()
			=> new ImageAccessorOperator<<#= ET #>, <#= T #>Accessor>(new <#= T #>Accessor(this));
	}

	internal struct <#= T #>Accessor : IImageAccessor<<#= ET #>>, IArrayImage<<#= ET #>>, IImageOperatorProvider<<#= ET #>>
	{
		public <#= T #>Accessor(<#= T #> image)
		{
			Image = image;
		}
		
        public IImage<<#= ET #>> Image { get; }
        <#= ET #>[] IArrayImage<<#= ET #>>.Array => ((IArrayImage<<#= ET #>>)Image).Array;

        public int Width => Image.Width;
        public int Height => Image.Height;

        public <#= ET #> this[int x, int y]
        {
            get => Image[x, y];
            set => Image[x, y] = value;
        }
		
        public IImageAccessor<<#= ET #>> CreateNew(int width, int height)
			=> new <#= T #>Accessor(new <#= T #>(width, height));

		IImageOperator<<#= ET #>> IImageOperatorProvider<<#= ET #>>.GetOperator()
			=> new ImageAccessorOperator<<#= ET #>, <#= T #>Accessor>(this);
	}
<#
}
#>
}
<#+

class ImageType
{
	public string TypeName;
	public System.Type ElementType;
	public System.Type AdditiveType;
}

#>